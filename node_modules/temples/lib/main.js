"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const yargs_1 = tslib_1.__importDefault(require("yargs/yargs"));
const lodash_1 = require("lodash");
const command_1 = require("@oclif/command");
const cli_1 = require("./cli");
const utils_1 = require("./utils");
const types_1 = require("./types");
const runner_1 = tslib_1.__importDefault(require("./runner"));
const TEMPLES_YAML = '.temples.yaml';
class Temples extends command_1.Command {
    /**
     * Get user props.
     *
     * @return {Props}
     */
    getUserProps() {
        const args = yargs_1.default(process.argv).argv;
        const flags = Object.keys(Temples.flags);
        return lodash_1.omit(args, '_', '$0', ...flags);
    }
    /**
     * Get temples configuration from yaml file.
     *
     * @param {string} p - path to config file
     *
     * @return {TemplesConfig}
     */
    getTemplesConfig(p) {
        const templesConfigFile = utils_1.readFile(path_1.default.resolve(process.cwd(), p));
        if (!templesConfigFile) {
            this.error('Configuration file not found or is empty. Create a .temples.yaml file.');
        }
        const templesConfig = yaml_1.default.parse(templesConfigFile);
        try {
            types_1.TemplesConfig.check(templesConfig);
            return templesConfig;
        }
        catch (e) {
            this.error(`Configuration file is invalid.\n\n${e}`);
        }
    }
    /**
     * Run temples CLI guide.
     *
     * @param {TemplesConfig} temples
     * @param {boolean} verbose
     */
    async cli(temples, verbose) {
        const { generators } = temples;
        const generator = await cli_1.promptGeneratorCommand(generators);
        const { props: propsToPrompt, default: defaultProps } = temples.generators[generator];
        const props = propsToPrompt
            ? await cli_1.promptProps(generator, propsToPrompt, defaultProps)
            : {};
        await runner_1.default(generator, props, temples, verbose);
    }
    /**
     * Primary runner for temples. This will parse user
     * CLI input, pull the config file, and run the CLI
     * guide if no generator comamnd is provided.
     */
    async run() {
        const { args, flags } = this.parse(Temples);
        const { generator } = args;
        const temples = this.getTemplesConfig(flags.config);
        const props = this.getUserProps();
        if (generator) {
            await runner_1.default(generator, props, temples, flags.verbose);
        }
        else {
            this.cli(temples, flags.verbose);
        }
    }
}
exports.default = Temples;
Temples.description = 'Automatically generate code from predefined templates. No more boilerplate.';
Temples.flags = {
    version: command_1.flags.version({ char: 'v' }),
    verbose: command_1.flags.boolean({ char: 'V', default: false }),
    config: command_1.flags.string({ char: 'c', default: TEMPLES_YAML }),
    help: command_1.flags.help({ char: 'h' }),
};
Temples.args = [{ name: 'generator' }];
Temples.usage = '[generator] --[prop]=[value] ...';
Temples.examples = [
    '$ temples',
    '$ temples component --name=Button --directory=containers',
];
/**
 * Set to false to manually parse
 * user's variable arguments
 *
 * Parsing unspecified flags is currently not
 * supported by oclif.
 */
Temples.strict = false;
