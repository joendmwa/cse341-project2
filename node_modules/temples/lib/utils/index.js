"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.truncate = exports.findMatchedRegExp = exports.writeFile = exports.readFile = exports.extract = exports.override = exports.isString = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const lodash_1 = require("lodash");
function isString(s) {
    return typeof s === 'string';
}
exports.isString = isString;
/**
 * Override keys and values from first
 * to last object.
 *
 * @param {object[]} objects
 *
 * @return {object} overridden object
 */
function override(...objects) {
    return objects.reduce((acc, o) => (Object.assign(Object.assign({}, acc), o)), objects[0]);
}
exports.override = override;
/**
 * Extract value found from first query
 * that yields a truthy value.
 *
 * If query is empty string, check original from argument.
 *
 * @param {any} from
 * @param {T} fallback
 * @param {(string | null)[]} queries
 *
 * @return {any | T}
 */
function extract(from, predicate, fallback, queries = []) {
    for (const query of queries) {
        const value = lodash_1.isEmpty(query) ? from : lodash_1.get(from, query);
        if (predicate(value)) {
            return value;
        }
    }
    return fallback;
}
exports.extract = extract;
/**
 * Read file from given path.
 *
 * @param {string} p - path
 *
 * @return {string} encoded file
 */
function readFile(p) {
    try {
        return fs_1.default.readFileSync(p, 'utf-8');
    }
    catch (e) {
        return null;
    }
}
exports.readFile = readFile;
/**
 * Write file to given path.
 *
 * @param {string} p - path to file
 * @param {string} content
 */
const writeFile = (p, content) => {
    const directory = path_1.default.dirname(p);
    if (!fs_1.default.existsSync(directory)) {
        fs_1.default.mkdirSync(directory, { recursive: true });
    }
    fs_1.default.writeFileSync(p, content);
};
exports.writeFile = writeFile;
/**
 * Find all matched regex substrings.
 *
 * @param {string} source
 * @param {string} regex - regex pattern
 *
 * @return {RegExpMatch[]} matching substrings
 */
function findMatchedRegExp(source, regex) {
    const matches = [];
    const matchesSet = new Set();
    if (lodash_1.isEmpty(regex)) {
        return matches;
    }
    const re = new RegExp(regex, 'gm');
    let m;
    while ((m = re.exec(source)) !== null) {
        if (m.index === re.lastIndex) {
            re.lastIndex++;
        }
        const [match, group = null] = m;
        if (matchesSet.has(match)) {
            continue;
        }
        matchesSet.add(match);
        matches.push([match, group]);
    }
    return matches;
}
exports.findMatchedRegExp = findMatchedRegExp;
/**
 * Truncate path to its parent directory and file name.
 *
 * @param {string} p
 *
 * @return {string} parent and file name
 */
function truncate(p) {
    const sections = p.split(path_1.default.sep);
    return lodash_1.takeRight(sections, 2).join(path_1.default.sep);
}
exports.truncate = truncate;
