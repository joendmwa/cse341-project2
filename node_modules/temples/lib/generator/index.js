"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListrGenerateInsert = exports.generateInsert = exports.ListrGenerateFile = exports.generateFile = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const lodash_1 = require("lodash");
const chalk_1 = require("chalk");
const utils_1 = require("../utils");
const insert_1 = tslib_1.__importDefault(require("../insert"));
const parser_1 = tslib_1.__importDefault(require("../parser"));
const DEFAULT_BASE_PATH = {
    templates: '',
    files: '',
    inserts: '',
};
/**
 * Get file extension.
 *
 * @param {string} file
 *
 * @return {string}
 */
function getFileExtension(file) {
    const extname = path_1.default.extname(file);
    return extname.replace('.', '');
}
/**
 * Generate a new file from template and props.
 *
 * @param {string} target - path to output
 * @param {string} template - path to template file
 * @param {Props} props
 * @param {BasePath} base - base paths
 */
function generateFile(target, template = '', props = {}, base = DEFAULT_BASE_PATH) {
    const templateWithBase = path_1.default.resolve(base.templates || '', template);
    const parsedTemplateWithBase = parser_1.default(templateWithBase, props);
    // If template is not provided, create empty file
    if (!template) {
        utils_1.writeFile(target, '');
        return;
    }
    const templateContent = utils_1.readFile(parsedTemplateWithBase);
    if (!templateContent) {
        throw new Error(`Template at ${parsedTemplateWithBase} does not exist.`);
    }
    const parsed = parser_1.default(templateContent, props);
    utils_1.writeFile(target, parsed);
}
exports.generateFile = generateFile;
/**
 * Generate a new file from template and props.
 *
 * @param {string} target - path to output
 * @param {string} template - path to template file
 * @param {Props} props
 * @param {BasePath} base - base paths
 */
function ListrGenerateFile(target, template = '', props = {}, base = DEFAULT_BASE_PATH) {
    const targetWithBase = path_1.default.resolve(base.files || '', target);
    const parsedTargetWithBase = parser_1.default(targetWithBase, props);
    return {
        title: chalk_1.cyan(utils_1.truncate(parsedTargetWithBase)),
        task: () => generateFile(parsedTargetWithBase, template, props, base),
    };
}
exports.ListrGenerateFile = ListrGenerateFile;
/**
 * Modify target file by inserting props.
 *
 * @param {string} target - file to modify
 * @param {RegExpConfig} regex - extensions to regex
 * @param {Props} props
 * @param {InsertPosition} position
 * @param {BasePath} base - base paths
 */
function generateInsert(target, regex = {}, props = {}, position = 'below', base = DEFAULT_BASE_PATH) {
    const targetContent = utils_1.readFile(target);
    const extension = getFileExtension(target);
    const extensionRegex = regex[extension];
    // User did not specify regex pattern for
    // target's file extension.
    if (!extensionRegex) {
        throw new Error(`Specify regex pattern for ${target}.`);
    }
    if (lodash_1.isNull(targetContent)) {
        throw new Error(`Target at ${target} does not exist.`);
    }
    const targetInserted = insert_1.default(targetContent, extensionRegex, props, {
        position,
    });
    utils_1.writeFile(target, targetInserted);
}
exports.generateInsert = generateInsert;
/**
 * Modify target file by inserting props.
 *
 * @param {string} target - file to modify
 * @param {RegExpConfig} regex - extensions to regex
 * @param {Props} props
 * @param {InsertPosition} position
 * @param {BasePath} base - base paths
 */
function ListrGenerateInsert(target, regex = {}, props = {}, position = 'below', base = DEFAULT_BASE_PATH) {
    const targetWithBase = path_1.default.resolve(base.inserts || '', target);
    const parsedTargetWithBase = parser_1.default(targetWithBase, props);
    return {
        title: chalk_1.cyan(utils_1.truncate(parsedTargetWithBase)),
        task: () => generateInsert(parsedTargetWithBase, regex, props, position, base),
    };
}
exports.ListrGenerateInsert = ListrGenerateInsert;
